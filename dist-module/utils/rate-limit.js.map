{"version":3,"sources":["utils/rate-limit.js"],"names":["rateLimit","fn","rate","count","args","proto","prop","baseFn","TypeError","queue","working","recurse","setTimeout","res","then","dequeue","length","shift","context","resolve","reject","apply","err","push"],"mappings":";;;;;AAAA;;;;;;;;;AASA,eAAe,SAASA,SAAT,CAAmBC,EAAnB,EAA+C;AAAA;AAAA,MAAxBC,IAAwB,uEAAjB,IAAiB;AAAA,MAAXC,KAAW,uEAAH,CAAG;;;AAG5D;AACA;AACA,MAAI,OAAOF,EAAP,KAAc,UAAlB,EAA8B;AAAA;AAC5B,UAAMG,OAAO,uBAAb;AACA;AAAA,WAAO,WAACC,KAAD,EAAQC,IAAR,EAAiB;AACtB,cAAMC,SAASF,MAAMC,IAAN,CAAf;AACA,cAAI,OAAOC,MAAP,KAAkB,UAAtB,EAAkC;AAChC,kBAAM,IAAIC,SAAJ,2BAAsCF,IAAtC,wBAAN;AACD;AACDD,gBAAMC,IAAN,IAAcN,4BAAUO,MAAV,4BAAqBH,IAArB,GAAd;AACD;AAND;AAF4B;;AAAA;AAS7B;;AAED,MAAMK,QAAQ,EAAd;AACA,MAAIC,UAAU,CAAd;;AAEA;;;AAGA,WAASC,OAAT,GAAmB;AACjB,WAAQ,aAAY;AAAA,aAAOC,WAAWC,GAAX,EAAgBX,IAAhB,CAAP;AAAA,KAAZ,CAAD,CACJY,IADI,CACC,YAAM;AACVJ;AACAK;AACD,KAJI,CAAP;AAKD;;AAED;;;AAGA,WAASA,OAAT,GAAmB;AACjB,QAAKN,MAAMO,MAAN,KAAiB,CAAlB,IAAyBN,YAAYP,KAAzC,EAAiD;AACjDO;AACAC;;AAHiB,uBAIwBF,MAAMQ,KAAN,EAJxB;;AAAA;;AAAA,QAIVC,OAJU;AAAA,QAIDd,IAJC;AAAA,QAIKe,OAJL;AAAA,QAIcC,MAJd;;AAKjB,QAAI;AACFD,cAAQlB,GAAGoB,KAAH,CAASH,OAAT,EAAkBd,IAAlB,CAAR;AACD,KAFD,CAEE,OAAOkB,GAAP,EAAY;AACZF,aAAOE,GAAP;AACD;AACF;;AAED;;;AAGA,SAAO,YAAkB;AAAA;;AAAA,sCAANlB,IAAM;AAANA,UAAM;AAAA;;AACvB,WAAO,aAAY,UAACe,OAAD,EAAUC,MAAV,EAAqB;AACtC,UAAI;AACFX,cAAMc,IAAN,CAAW,QAAOnB,IAAP,EAAae,OAAb,EAAsBC,MAAtB,CAAX;AACA,YAAIV,UAAUP,KAAd,EAAqBY;AACtB,OAHD,CAGE,OAAOO,GAAP,EAAY;AACZF,eAAOE,GAAP;AACD;AACF,KAPM,CAAP;AAQD,GATD;AAUD","file":"utils/rate-limit.js","sourcesContent":["/**\n * Limit calls of this function to at most 1/rate,\n * where rate is in milliseconds. Instead of grouping (like _.debounce)\n * calls are added to a queue and executed serially.\n *\n * @param fn ?: function to rate limit\n * @param rate : milliseconds to wait between invocations\n * @param count : maximum concurrent calls between wait periods\n */\nexport default function rateLimit(fn, rate = 1000, count = 1) {\n\n\n  // if first arg is not number,\n  // assume decorator syntax, return curried decorator\n  if (typeof fn !== 'function') {\n    const args = Array.from(arguments);\n    return (proto, prop) => {\n      const baseFn = proto[prop];\n      if (typeof baseFn !== 'function') {\n        throw new TypeError(`Cannot wrap property ${prop}, must be function`);\n      }\n      proto[prop] = rateLimit(baseFn, ...args);\n    };\n  }\n\n  const queue = [];\n  let working = 0;\n\n  /**\n   * Continue dequeing jobs at rate limited pace\n   */\n  function recurse() {\n    return (new Promise(res => setTimeout(res, rate)))\n      .then(() => {\n        working--;\n        dequeue();\n      });\n  }\n\n  /**\n   * Run a job if it exists\n   */\n  function dequeue() {\n    if ((queue.length === 0) || (working === count)) return;\n    working++;\n    recurse();\n    const [context, args, resolve, reject] = queue.shift();\n    try {\n      resolve(fn.apply(context, args));\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  /**\n   * Returned wrapped function, keeping correct context\n   */\n  return function(...args) {\n    return new Promise((resolve, reject) => {\n      try {\n        queue.push([this, args, resolve, reject]);\n        if (working < count) dequeue();\n      } catch (err) {\n        reject(err);\n      }\n    });\n  };\n}"],"sourceRoot":"/source/"}