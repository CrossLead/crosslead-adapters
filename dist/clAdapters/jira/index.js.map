{"version":3,"sources":["clAdapters/jira/index.js"],"names":["JiraAdapter","apiVersion","path","query","uri","format","protocol","credentials","hostname","host","port","pathname","authorizationString","Buffer","username","password","toString","options","method","headers","qs","resolve","error","response","body","errorMessage","success","statusCode","code","message","data","params","requestParams","startAt","maxResults","resultCount","issues","makeRequest","result","JSON","parse","length","concat","projectId","getAllIssues","jql","startDate","endDate","formattedStartDate","formattedEndDate","epicId","issueTypes","join"],"mappings":"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","file":"clAdapters/jira/index.js","sourcesContent":["import Adapter from '../base/Adapter';\nimport moment from 'moment';\nimport url from 'url';\nimport request from 'request';\nimport rateLimit from '../../utils/rate-limit';\n\nexport default class JiraAdapter extends Adapter {\n  constructor() {\n    super();\n    this.apiVersion = 2;\n  }\n\n  init() {}\n\n  /**\n   * Rate limit api requests to once per second\n   */\n  @rateLimit(200)\n  makeRequest(path, query) {\n    const uri = url.format({\n      protocol: this.credentials.protocol || 'https',\n      hostname: this.credentials.host,\n      port: this.credentials.port,\n      pathname: 'rest/api/' + this.apiVersion + '/' + path\n    });\n\n    const authorizationString = new Buffer(\n      this.credentials.username + ':' + this.credentials.password\n    ).toString('base64');\n\n    const options = {\n      uri: uri,\n      method: 'GET',\n      headers: {\n        'Authorization': 'Basic ' + authorizationString\n      }\n    };\n\n    if (query) {\n      options.qs = query;\n    }\n\n    return new Promise((resolve) => {\n      request(options, (error, response, body) => {\n        let errorMessage = null;\n        let success = response && response.statusCode < 400;\n\n        if (error) {\n          success = false;\n          if (error.code === 'ECONNREFUSED') {\n            errorMessage = 'Failed to connect to JIRA adapter.';\n          }\n        }\n\n        if (response && response.statusCode === 401) {\n          success = false;\n          errorMessage = 'Failed to authorize JIRA adapter.';\n        }\n\n        resolve({\n          code: success ? 200 : 500,\n          message: errorMessage || error,\n          data: body,\n          success: success\n        });\n      });\n    });\n  }\n\n  async getAllIssues(params) {\n    const requestParams = params || {};\n    requestParams.startAt = 0;\n    requestParams.maxResults = 50;\n\n    let resultCount,\n        issues = [];\n    do {\n      const result = await this.makeRequest('search', requestParams),\n            data = JSON.parse(result.data);\n\n      if (data.issues && data.issues.length) {\n        resultCount = data.issues.length;\n        issues = issues.concat(data.issues);\n        requestParams.startAt += resultCount;\n      } else {\n        resultCount = 0;\n      }\n    } while (resultCount && resultCount === requestParams.maxResults);\n\n    return issues;\n  }\n\n  runConnectionTest() {\n    return this.makeRequest('myself');\n  }\n\n  getIssueHierarchy() {\n    return this.makeRequest('issue/createmeta');\n  }\n\n  getUnresolvedEpicsForProject(projectId) {\n    return this.getAllIssues({\n      jql: `project = ${projectId} AND issuetype = Epic AND resolution = Unresolved`\n    });\n  }\n\n  getEpicsForProject(projectId, startDate, endDate) {\n    const formattedStartDate = moment(startDate).format('YYYY/MM/DD HH:mm'),\n          formattedEndDate = moment(endDate).format('YYYY/MM/DD HH:mm');\n\n    return this.getAllIssues({\n      jql: `project = ${projectId} AND issuetype = Epic AND\n      updatedDate >= \"${formattedStartDate}\" AND updatedDate <= \"${formattedEndDate}\"`\n    });\n  }\n\n  getIssuesForEpic(epicId, issueTypes, startDate, endDate) {\n    const formattedStartDate = moment(startDate).format('YYYY/MM/DD HH:mm'),\n          formattedEndDate = moment(endDate).format('YYYY/MM/DD HH:mm');\n\n    return this.getAllIssues({\n      jql: `(\"Epic Link\" = ${epicId} OR parent IN tempoEpicIssues(${epicId})) AND\n        issuetype IN (${issueTypes.join(',')}) AND\n        updatedDate >= \"${formattedStartDate}\" AND updatedDate <= \"${formattedEndDate}\"`\n    });\n  }\n}\n"],"sourceRoot":"/source/"}