{"version":3,"sources":["clAdapters/google-calendar/index.js"],"names":["calendar","credentialMappings","GoogleCalendarAdapter","_config","_service","credentials","Error","want","alternate","Object","keys","forEach","prop","Configuration","Service","init","email","serviceEmail","console","log","userProfiles","filterStartDate","filterEndDate","fieldNameMap","constructor","opts","alwaysIncludeEmail","calendarId","singleEvents","timeMax","toISOString","timeMin","orderBy","groupRunStats","success","runDate","utc","toDate","emails","Promise","all","map","userProfile","individualRunStats","authorize","emailAfterMapping","auth","getEvents","data","res","rej","nextPageToken","pageToken","events","list","err","d","items","push","out","each","have","modified","get","item","test","Date","undefined","attendeeSelf","find","attendees","attendee","self","responseStatus","address","response","assign","stack","errorMessage","toString","results","getBatchData","add","error","warn","runConnectionTest","certificate","JWT"],"mappings":"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","file":"clAdapters/google-calendar/index.js","sourcesContent":["import googleapis from 'googleapis';\nimport moment     from 'moment';\nimport _          from 'lodash';\nimport { Adapter, Configuration, Service } from '../base/index';\n\n// google calendar api\nconst calendar = googleapis.calendar('v3');\n\nconst credentialMappings = {\n  'certificate' : 'private_key',\n  'serviceEmail': 'client_email',\n  'email'       : 'adminEmail'\n};\n\n\nexport default class GoogleCalendarAdapter extends Adapter {\n\n  static Configuration = Configuration;\n  static Service = Service;\n\n  // convert the names of the api response data\n  static fieldNameMap = {\n    // Desired...                          // Given...\n    'eventId':                             'id',\n    'attendees':                           'attendees',\n    'dateTimeCreated':                     'created',\n    'dateTimeLastModified':                'updated',\n    'attendeeAddress':                     'EmailAddress.Address',\n    'attendeeName':                        'EmailAddress.Name',\n    'iCalUId':                             'iCalUID',\n    'location':                            'location',\n    'status':                              'status',\n    'isCreator':                           'creator.self',\n    'isOrganizer':                         'organizer.self',\n    'organizerEmail':                      'organizer.email',\n    'recurrance':                          'recurrance',\n    'responseStatus':                      'responseStatus',\n    'dateTimeStart':                       'start.dateTime',\n    'dateTimeEnd':                         'end.dateTime',\n    'subject':                             'summary',\n    'url':                                 'htmlLink',\n    'hangoutLink':                         'hangoutLink',\n    'privacy':                             'visibility'\n  }\n\n  // constructor needs to call super\n  constructor() {\n    super();\n  }\n\n\n  reset() {\n    delete this._config;\n    delete this._service;\n    return this;\n  }\n\n\n  async init() {\n\n    const { credentials } = this;\n\n    if (!credentials) {\n      throw new Error('credentials required for adapter.');\n    }\n\n    // map Google json keys to keys used in this library\n    for (const want in credentialMappings) {\n      const alternate = credentialMappings[want];\n      if (!credentials[want]) {\n        credentials[want] = credentials[alternate];\n      }\n    }\n\n    // validate required credential properties\n    Object.keys(credentialMappings)\n      .forEach(prop => {\n        if (!credentials[prop]) {\n          throw new Error(`Property ${prop} required in adapter credentials!`);\n        }\n      });\n\n    this._config  = new GoogleCalendarAdapter.Configuration(credentials);\n    this._service = new GoogleCalendarAdapter.Service(this._config);\n\n    await this._service.init();\n\n    const { serviceEmail: email } = credentials;\n\n    console.log(\n      `Successfully initialized google calendar adapter for email: ${email}`\n    );\n\n    return this;\n  }\n\n\n  // currently doing nothing with fields here, but keeping as placeholder\n  async getBatchData(userProfiles = [], filterStartDate, filterEndDate /*, fields */) {\n\n    const { fieldNameMap } = this.constructor;\n\n    // api options...\n    // https://developers.google.com/google-apps/calendar/v3/\n    const opts = {\n      alwaysIncludeEmail:   true,\n      calendarId:           'primary',\n      singleEvents:         true,\n      timeMax:              filterEndDate.toISOString(),\n      timeMin:              filterStartDate.toISOString(),\n      orderBy:              'startTime'\n    };\n\n\n    const groupRunStats = {\n      success: true,\n      runDate: moment().utc().toDate(),\n      filterStartDate: filterStartDate,\n      filterEndDate: filterEndDate,\n      emails: userProfiles\n    };\n\n\n    try {\n\n      // collect events for this group of emails\n      const results = await Promise.all(userProfiles.map(async(userProfile) => {\n\n        const individualRunStats = {\n          filterStartDate,\n          filterEndDate,\n          ...userProfile,\n          success: true,\n          runDate: moment().utc().toDate()\n        };\n\n        try {\n          // add auth tokens to request\n          opts.auth = await this.authorize(userProfile.emailAfterMapping);\n\n          // function to recurse through pageTokens\n          const getEvents = async(data) => {\n\n            // request first results...\n            const events = await new Promise((res, rej) => {\n              // add page token if given\n              if (data && data.nextPageToken) {\n                opts.pageToken = data.nextPageToken;\n              }\n\n              calendar.events.list(\n                opts, (err, d) => err ? rej(err) : res(d)\n              );\n            });\n\n            // if we already have data being accumulated, add to items\n            if (data) {\n              data.items.push(...events.items);\n            } else {\n              data = events;\n            }\n\n            // if there is a token for the next page, continue...\n            if (events.nextPageToken) {\n              data.nextPageToken = events.nextPageToken;\n              return await getEvents(data);\n            }\n\n            return data;\n          };\n\n          const { items } = await getEvents();\n\n          const data = _.map(items, item => {\n\n            const out = {};\n\n            _.each(fieldNameMap, (have, want) => {\n              let modified = _.get(item, have);\n              if (/^dateTime/.test(want)) {\n                modified = new Date(modified);\n              }\n              if (modified !== undefined) {\n                out[want] = modified;\n              }\n            });\n\n\n            const attendeeSelf = _.find(out.attendees, (attendee) => {\n              return attendee.self;\n            });\n\n            if (attendeeSelf) {\n              out.responseStatus = attendeeSelf.responseStatus;\n            }\n\n            out.attendees = _.map(out.attendees, attendee => {\n              const { email, responseStatus } = attendee;\n              return { address: email, response: responseStatus };\n            });\n\n            return out;\n          });\n\n          // request all events for this user in the given time frame\n          return Object.assign(individualRunStats, { data });\n\n        } catch (error) {\n          // if the batch collection failed...\n          console.log('GoogleCalendarAdapter.getBatchData Error:', error.stack);\n\n          let errorMessage = error;\n\n          if (/invalid_grant/.test(errorMessage.toString())) {\n            errorMessage = `Email address: ${userProfile.emailAfterMapping} not found in this Google Calendar account.`;\n          }\n\n          return Object.assign(individualRunStats, {\n            errorMessage,\n            success: false,\n            data: []\n          });\n        }\n\n      }));\n\n      return Object.assign(groupRunStats, { results });\n    } catch (error) {\n      return Object.assign(groupRunStats, {\n        errorMessage: error,\n        success: false\n      });\n    }\n\n  }\n\n\n  async runConnectionTest() {\n    const { credentials: { email } } = this;\n\n    try {\n      const data = await this.getBatchData(\n        [ { email, emailAfterMapping: email } ],\n        moment().toDate(),\n        moment().add(-1, 'day').toDate()\n      );\n\n      return data;\n    } catch (error) {\n      console.log(error.stack || error);\n      return {\n        error,\n        success: false\n      };\n    }\n  }\n\n\n  async runMessageTest() {\n    // TODO: does this need to be different?\n    console.warn('Note: runMessageTest() currently calls runConnectionTest()');\n    return this.runConnectionTest();\n  }\n\n\n  // create authenticated token for api requests for given user\n  async authorize(email) {\n\n    const { credentials: { serviceEmail, certificate } } = this;\n\n    const auth = new googleapis.auth.JWT(\n      // email of google app admin...\n      serviceEmail,\n      // no need for keyFile...\n      null,\n      // the private key itself...\n      certificate,\n      // scopes...\n      ['https://www.googleapis.com/auth/calendar.readonly'],\n      // the email of the individual we want to authenticate\n      // ('sub' property of the json web token)\n      email\n    );\n\n    // await authorization\n    return new Promise((res, rej) => auth.authorize(err => {\n      err ? rej(err) : res(auth);\n    }));\n  }\n\n}\n"],"sourceRoot":"/source/"}